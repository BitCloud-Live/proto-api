// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.2
// source: YB.proto

package yb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	YB_Login_FullMethodName                        = "/yb.YB/Login"
	YB_Logout_FullMethodName                       = "/yb.YB/Logout"
	YB_AccountInfo_FullMethodName                  = "/yb.YB/AccountInfo"
	YB_AccountUpdate_FullMethodName                = "/yb.YB/AccountUpdate"
	YB_MonitoringQuota_FullMethodName              = "/yb.YB/MonitoringQuota"
	YB_MonitoringResource_FullMethodName           = "/yb.YB/MonitoringResource"
	YB_MonitoringTraffic_FullMethodName            = "/yb.YB/MonitoringTraffic"
	YB_MonitoringLatency_FullMethodName            = "/yb.YB/MonitoringLatency"
	YB_ActivityList_FullMethodName                 = "/yb.YB/ActivityList"
	YB_DomainList_FullMethodName                   = "/yb.YB/DomainList"
	YB_DomainInfo_FullMethodName                   = "/yb.YB/DomainInfo"
	YB_DomainToggleTLS_FullMethodName              = "/yb.YB/DomainToggleTLS"
	YB_DomainCreate_FullMethodName                 = "/yb.YB/DomainCreate"
	YB_DomainDelete_FullMethodName                 = "/yb.YB/DomainDelete"
	YB_VolumeSpecList_FullMethodName               = "/yb.YB/VolumeSpecList"
	YB_VolumeList_FullMethodName                   = "/yb.YB/VolumeList"
	YB_VolumeInfo_FullMethodName                   = "/yb.YB/VolumeInfo"
	YB_VolumeCreate_FullMethodName                 = "/yb.YB/VolumeCreate"
	YB_VolumeDelete_FullMethodName                 = "/yb.YB/VolumeDelete"
	YB_VolumeFTPPortforward_FullMethodName         = "/yb.YB/VolumeFTPPortforward"
	YB_ImgList_FullMethodName                      = "/yb.YB/ImgList"
	YB_ImgInfo_FullMethodName                      = "/yb.YB/ImgInfo"
	YB_ImgDelete_FullMethodName                    = "/yb.YB/ImgDelete"
	YB_ImgBuild_FullMethodName                     = "/yb.YB/ImgBuild"
	YB_ImgBuildLog_FullMethodName                  = "/yb.YB/ImgBuildLog"
	YB_ImgBuildLogTail_FullMethodName              = "/yb.YB/ImgBuildLogTail"
	YB_PrdList_FullMethodName                      = "/yb.YB/PrdList"
	YB_PrdInfo_FullMethodName                      = "/yb.YB/PrdInfo"
	YB_SrvList_FullMethodName                      = "/yb.YB/SrvList"
	YB_SrvInfo_FullMethodName                      = "/yb.YB/SrvInfo"
	YB_SrvCreate_FullMethodName                    = "/yb.YB/SrvCreate"
	YB_SrvDestroy_FullMethodName                   = "/yb.YB/SrvDestroy"
	YB_SrvStart_FullMethodName                     = "/yb.YB/SrvStart"
	YB_SrvStop_FullMethodName                      = "/yb.YB/SrvStop"
	YB_SrvAttachDomain_FullMethodName              = "/yb.YB/SrvAttachDomain"
	YB_SrvDetachDomain_FullMethodName              = "/yb.YB/SrvDetachDomain"
	YB_SrvOperator_FullMethodName                  = "/yb.YB/SrvOperator"
	YB_SrvPortforward_FullMethodName               = "/yb.YB/SrvPortforward"
	YB_SrvConfigSet_FullMethodName                 = "/yb.YB/SrvConfigSet"
	YB_SrvConfigUnset_FullMethodName               = "/yb.YB/SrvConfigUnset"
	YB_AppList_FullMethodName                      = "/yb.YB/AppList"
	YB_AppInfo_FullMethodName                      = "/yb.YB/AppInfo"
	YB_AppCreate_FullMethodName                    = "/yb.YB/AppCreate"
	YB_AppDestroy_FullMethodName                   = "/yb.YB/AppDestroy"
	YB_AppChangePlan_FullMethodName                = "/yb.YB/AppChangePlan"
	YB_AppLog_FullMethodName                       = "/yb.YB/AppLog"
	YB_AppLogTail_FullMethodName                   = "/yb.YB/AppLogTail"
	YB_AppConfigSet_FullMethodName                 = "/yb.YB/AppConfigSet"
	YB_AppConfigUnset_FullMethodName               = "/yb.YB/AppConfigUnset"
	YB_AppAddEnvironmentVariable_FullMethodName    = "/yb.YB/AppAddEnvironmentVariable"
	YB_AppRemoveEnvironmentVariable_FullMethodName = "/yb.YB/AppRemoveEnvironmentVariable"
	YB_AppReset_FullMethodName                     = "/yb.YB/AppReset"
	YB_AppStop_FullMethodName                      = "/yb.YB/AppStop"
	YB_AppStart_FullMethodName                     = "/yb.YB/AppStart"
	YB_AppShell_FullMethodName                     = "/yb.YB/AppShell"
	YB_AppAttachVolume_FullMethodName              = "/yb.YB/AppAttachVolume"
	YB_AppDetachVolume_FullMethodName              = "/yb.YB/AppDetachVolume"
	YB_AppAttachDomain_FullMethodName              = "/yb.YB/AppAttachDomain"
	YB_AppDetachDomain_FullMethodName              = "/yb.YB/AppDetachDomain"
	YB_AppSrvBind_FullMethodName                   = "/yb.YB/AppSrvBind"
	YB_AppSrvUnBind_FullMethodName                 = "/yb.YB/AppSrvUnBind"
	YB_AppFTPPortforward_FullMethodName            = "/yb.YB/AppFTPPortforward"
)

// YBClient is the client API for YB service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type YBClient interface {
	// Authentication
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*AuthenticationRes, error)
	Logout(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Account, error)
	AccountUpdate(ctx context.Context, in *Account, opts ...grpc.CallOption) (*Account, error)
	// Monitoring
	MonitoringQuota(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ResourcesRes, error)
	MonitoringResource(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ResourcesRes, error)
	MonitoringTraffic(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*TrafficRes, error)
	MonitoringLatency(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*LatencyRes, error)
	ActivityList(ctx context.Context, in *ActivityReq, opts ...grpc.CallOption) (*ActivityListRes, error)
	// Domain
	DomainList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*DomainListRes, error)
	DomainInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*DomainStatusRes, error)
	DomainToggleTLS(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*DomainStatusRes, error)
	DomainCreate(ctx context.Context, in *DomainCreateReq, opts ...grpc.CallOption) (*DomainStatusRes, error)
	DomainDelete(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error)
	// Volume
	VolumeSpecList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*VolumeSpecListRes, error)
	VolumeList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*VolumeListRes, error)
	VolumeInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*VolumeStatusRes, error)
	VolumeCreate(ctx context.Context, in *VolumeCreateReq, opts ...grpc.CallOption) (*VolumeStatusRes, error)
	VolumeDelete(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error)
	// Deprecated
	VolumeFTPPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error)
	// Image
	ImgList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*ImgListRes, error)
	ImgInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ImgStatusRes, error)
	ImgDelete(ctx context.Context, in *ImgBuildReq, opts ...grpc.CallOption) (*Empty, error)
	ImgBuild(ctx context.Context, in *ImgBuildReq, opts ...grpc.CallOption) (*Empty, error)
	ImgBuildLog(ctx context.Context, in *Identity, opts ...grpc.CallOption) (YB_ImgBuildLogClient, error)
	ImgBuildLogTail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*Chunk, error)
	// Product
	PrdList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PrdListRes, error)
	PrdInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ProductRes, error)
	// Service
	SrvList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*SrvListRes, error)
	SrvInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvCreate(ctx context.Context, in *SrvCreateReq, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvDestroy(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error)
	SrvStart(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvStop(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvAttachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvDetachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvOperator(ctx context.Context, in *PunchedCard, opts ...grpc.CallOption) (*OperatorRes, error)
	SrvPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error)
	// Added in v2.1 patch
	SrvConfigSet(ctx context.Context, in *SrvConfigSetReq, opts ...grpc.CallOption) (*SrvStatusRes, error)
	SrvConfigUnset(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*SrvStatusRes, error)
	// Application
	AppList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*SrvListRes, error)
	AppInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppCreate(ctx context.Context, in *AppCreateReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppDestroy(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error)
	AppChangePlan(ctx context.Context, in *ChangePlanReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppLog(ctx context.Context, in *Identity, opts ...grpc.CallOption) (YB_AppLogClient, error)
	AppLogTail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*Chunk, error)
	AppConfigSet(ctx context.Context, in *SrvConfigSetReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppConfigUnset(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppAddEnvironmentVariable(ctx context.Context, in *AppAddEnvironmentVariableReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppRemoveEnvironmentVariable(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppReset(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppStop(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppStart(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error)
	// TTY disable for now
	AppShell(ctx context.Context, in *ShellReq, opts ...grpc.CallOption) (*Chunk, error)
	AppAttachVolume(ctx context.Context, in *VolumeMount, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppDetachVolume(ctx context.Context, in *AttachIdentity, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppAttachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppDetachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppSrvBind(ctx context.Context, in *AppSrvBindReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppSrvUnBind(ctx context.Context, in *AppSrvBindReq, opts ...grpc.CallOption) (*AppStatusRes, error)
	AppFTPPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error)
}

type yBClient struct {
	cc grpc.ClientConnInterface
}

func NewYBClient(cc grpc.ClientConnInterface) YBClient {
	return &yBClient{cc}
}

func (c *yBClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*AuthenticationRes, error) {
	out := new(AuthenticationRes)
	err := c.cc.Invoke(ctx, YB_Login_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) Logout(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_Logout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AccountInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, YB_AccountInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AccountUpdate(ctx context.Context, in *Account, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, YB_AccountUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) MonitoringQuota(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ResourcesRes, error) {
	out := new(ResourcesRes)
	err := c.cc.Invoke(ctx, YB_MonitoringQuota_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) MonitoringResource(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ResourcesRes, error) {
	out := new(ResourcesRes)
	err := c.cc.Invoke(ctx, YB_MonitoringResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) MonitoringTraffic(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*TrafficRes, error) {
	out := new(TrafficRes)
	err := c.cc.Invoke(ctx, YB_MonitoringTraffic_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) MonitoringLatency(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*LatencyRes, error) {
	out := new(LatencyRes)
	err := c.cc.Invoke(ctx, YB_MonitoringLatency_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ActivityList(ctx context.Context, in *ActivityReq, opts ...grpc.CallOption) (*ActivityListRes, error) {
	out := new(ActivityListRes)
	err := c.cc.Invoke(ctx, YB_ActivityList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) DomainList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*DomainListRes, error) {
	out := new(DomainListRes)
	err := c.cc.Invoke(ctx, YB_DomainList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) DomainInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*DomainStatusRes, error) {
	out := new(DomainStatusRes)
	err := c.cc.Invoke(ctx, YB_DomainInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) DomainToggleTLS(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*DomainStatusRes, error) {
	out := new(DomainStatusRes)
	err := c.cc.Invoke(ctx, YB_DomainToggleTLS_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) DomainCreate(ctx context.Context, in *DomainCreateReq, opts ...grpc.CallOption) (*DomainStatusRes, error) {
	out := new(DomainStatusRes)
	err := c.cc.Invoke(ctx, YB_DomainCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) DomainDelete(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_DomainDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeSpecList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*VolumeSpecListRes, error) {
	out := new(VolumeSpecListRes)
	err := c.cc.Invoke(ctx, YB_VolumeSpecList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*VolumeListRes, error) {
	out := new(VolumeListRes)
	err := c.cc.Invoke(ctx, YB_VolumeList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*VolumeStatusRes, error) {
	out := new(VolumeStatusRes)
	err := c.cc.Invoke(ctx, YB_VolumeInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeCreate(ctx context.Context, in *VolumeCreateReq, opts ...grpc.CallOption) (*VolumeStatusRes, error) {
	out := new(VolumeStatusRes)
	err := c.cc.Invoke(ctx, YB_VolumeCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeDelete(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_VolumeDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) VolumeFTPPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error) {
	out := new(PortforwardRes)
	err := c.cc.Invoke(ctx, YB_VolumeFTPPortforward_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ImgList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*ImgListRes, error) {
	out := new(ImgListRes)
	err := c.cc.Invoke(ctx, YB_ImgList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ImgInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ImgStatusRes, error) {
	out := new(ImgStatusRes)
	err := c.cc.Invoke(ctx, YB_ImgInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ImgDelete(ctx context.Context, in *ImgBuildReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_ImgDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ImgBuild(ctx context.Context, in *ImgBuildReq, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_ImgBuild_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) ImgBuildLog(ctx context.Context, in *Identity, opts ...grpc.CallOption) (YB_ImgBuildLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &YB_ServiceDesc.Streams[0], YB_ImgBuildLog_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yBImgBuildLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type YB_ImgBuildLogClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type yBImgBuildLogClient struct {
	grpc.ClientStream
}

func (x *yBImgBuildLogClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yBClient) ImgBuildLogTail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*Chunk, error) {
	out := new(Chunk)
	err := c.cc.Invoke(ctx, YB_ImgBuildLogTail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) PrdList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*PrdListRes, error) {
	out := new(PrdListRes)
	err := c.cc.Invoke(ctx, YB_PrdList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) PrdInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*ProductRes, error) {
	out := new(ProductRes)
	err := c.cc.Invoke(ctx, YB_PrdInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvList(ctx context.Context, in *AppListReq, opts ...grpc.CallOption) (*SrvListRes, error) {
	out := new(SrvListRes)
	err := c.cc.Invoke(ctx, YB_SrvList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvCreate(ctx context.Context, in *SrvCreateReq, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvDestroy(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_SrvDestroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvStart(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvStart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvStop(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvStop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvAttachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvAttachDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvDetachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvDetachDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvOperator(ctx context.Context, in *PunchedCard, opts ...grpc.CallOption) (*OperatorRes, error) {
	out := new(OperatorRes)
	err := c.cc.Invoke(ctx, YB_SrvOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error) {
	out := new(PortforwardRes)
	err := c.cc.Invoke(ctx, YB_SrvPortforward_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvConfigSet(ctx context.Context, in *SrvConfigSetReq, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvConfigSet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) SrvConfigUnset(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*SrvStatusRes, error) {
	out := new(SrvStatusRes)
	err := c.cc.Invoke(ctx, YB_SrvConfigUnset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppList(ctx context.Context, in *ListReq, opts ...grpc.CallOption) (*SrvListRes, error) {
	out := new(SrvListRes)
	err := c.cc.Invoke(ctx, YB_AppList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppInfo(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppCreate(ctx context.Context, in *AppCreateReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppDestroy(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, YB_AppDestroy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppChangePlan(ctx context.Context, in *ChangePlanReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppChangePlan_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppLog(ctx context.Context, in *Identity, opts ...grpc.CallOption) (YB_AppLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &YB_ServiceDesc.Streams[1], YB_AppLog_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &yBAppLogClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type YB_AppLogClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type yBAppLogClient struct {
	grpc.ClientStream
}

func (x *yBAppLogClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *yBClient) AppLogTail(ctx context.Context, in *TailRequest, opts ...grpc.CallOption) (*Chunk, error) {
	out := new(Chunk)
	err := c.cc.Invoke(ctx, YB_AppLogTail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppConfigSet(ctx context.Context, in *SrvConfigSetReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppConfigSet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppConfigUnset(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppConfigUnset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppAddEnvironmentVariable(ctx context.Context, in *AppAddEnvironmentVariableReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppAddEnvironmentVariable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppRemoveEnvironmentVariable(ctx context.Context, in *UnsetReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppRemoveEnvironmentVariable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppReset(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppReset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppStop(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppStop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppStart(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppStart_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppShell(ctx context.Context, in *ShellReq, opts ...grpc.CallOption) (*Chunk, error) {
	out := new(Chunk)
	err := c.cc.Invoke(ctx, YB_AppShell_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppAttachVolume(ctx context.Context, in *VolumeMount, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppAttachVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppDetachVolume(ctx context.Context, in *AttachIdentity, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppDetachVolume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppAttachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppAttachDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppDetachDomain(ctx context.Context, in *SrvDomainAttachReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppDetachDomain_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppSrvBind(ctx context.Context, in *AppSrvBindReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppSrvBind_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppSrvUnBind(ctx context.Context, in *AppSrvBindReq, opts ...grpc.CallOption) (*AppStatusRes, error) {
	out := new(AppStatusRes)
	err := c.cc.Invoke(ctx, YB_AppSrvUnBind_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *yBClient) AppFTPPortforward(ctx context.Context, in *Identity, opts ...grpc.CallOption) (*PortforwardRes, error) {
	out := new(PortforwardRes)
	err := c.cc.Invoke(ctx, YB_AppFTPPortforward_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// YBServer is the server API for YB service.
// All implementations must embed UnimplementedYBServer
// for forward compatibility
type YBServer interface {
	// Authentication
	Login(context.Context, *LoginReq) (*AuthenticationRes, error)
	Logout(context.Context, *Empty) (*Empty, error)
	AccountInfo(context.Context, *Empty) (*Account, error)
	AccountUpdate(context.Context, *Account) (*Account, error)
	// Monitoring
	MonitoringQuota(context.Context, *Empty) (*ResourcesRes, error)
	MonitoringResource(context.Context, *Identity) (*ResourcesRes, error)
	MonitoringTraffic(context.Context, *Identity) (*TrafficRes, error)
	MonitoringLatency(context.Context, *Identity) (*LatencyRes, error)
	ActivityList(context.Context, *ActivityReq) (*ActivityListRes, error)
	// Domain
	DomainList(context.Context, *AppListReq) (*DomainListRes, error)
	DomainInfo(context.Context, *Identity) (*DomainStatusRes, error)
	DomainToggleTLS(context.Context, *Identity) (*DomainStatusRes, error)
	DomainCreate(context.Context, *DomainCreateReq) (*DomainStatusRes, error)
	DomainDelete(context.Context, *Identity) (*Empty, error)
	// Volume
	VolumeSpecList(context.Context, *ListReq) (*VolumeSpecListRes, error)
	VolumeList(context.Context, *AppListReq) (*VolumeListRes, error)
	VolumeInfo(context.Context, *Identity) (*VolumeStatusRes, error)
	VolumeCreate(context.Context, *VolumeCreateReq) (*VolumeStatusRes, error)
	VolumeDelete(context.Context, *Identity) (*Empty, error)
	// Deprecated
	VolumeFTPPortforward(context.Context, *Identity) (*PortforwardRes, error)
	// Image
	ImgList(context.Context, *AppListReq) (*ImgListRes, error)
	ImgInfo(context.Context, *Identity) (*ImgStatusRes, error)
	ImgDelete(context.Context, *ImgBuildReq) (*Empty, error)
	ImgBuild(context.Context, *ImgBuildReq) (*Empty, error)
	ImgBuildLog(*Identity, YB_ImgBuildLogServer) error
	ImgBuildLogTail(context.Context, *TailRequest) (*Chunk, error)
	// Product
	PrdList(context.Context, *ListReq) (*PrdListRes, error)
	PrdInfo(context.Context, *Identity) (*ProductRes, error)
	// Service
	SrvList(context.Context, *AppListReq) (*SrvListRes, error)
	SrvInfo(context.Context, *Identity) (*SrvStatusRes, error)
	SrvCreate(context.Context, *SrvCreateReq) (*SrvStatusRes, error)
	SrvDestroy(context.Context, *Identity) (*Empty, error)
	SrvStart(context.Context, *Identity) (*SrvStatusRes, error)
	SrvStop(context.Context, *Identity) (*SrvStatusRes, error)
	SrvAttachDomain(context.Context, *SrvDomainAttachReq) (*SrvStatusRes, error)
	SrvDetachDomain(context.Context, *SrvDomainAttachReq) (*SrvStatusRes, error)
	SrvOperator(context.Context, *PunchedCard) (*OperatorRes, error)
	SrvPortforward(context.Context, *Identity) (*PortforwardRes, error)
	// Added in v2.1 patch
	SrvConfigSet(context.Context, *SrvConfigSetReq) (*SrvStatusRes, error)
	SrvConfigUnset(context.Context, *UnsetReq) (*SrvStatusRes, error)
	// Application
	AppList(context.Context, *ListReq) (*SrvListRes, error)
	AppInfo(context.Context, *Identity) (*AppStatusRes, error)
	AppCreate(context.Context, *AppCreateReq) (*AppStatusRes, error)
	AppDestroy(context.Context, *Identity) (*Empty, error)
	AppChangePlan(context.Context, *ChangePlanReq) (*AppStatusRes, error)
	AppLog(*Identity, YB_AppLogServer) error
	AppLogTail(context.Context, *TailRequest) (*Chunk, error)
	AppConfigSet(context.Context, *SrvConfigSetReq) (*AppStatusRes, error)
	AppConfigUnset(context.Context, *UnsetReq) (*AppStatusRes, error)
	AppAddEnvironmentVariable(context.Context, *AppAddEnvironmentVariableReq) (*AppStatusRes, error)
	AppRemoveEnvironmentVariable(context.Context, *UnsetReq) (*AppStatusRes, error)
	AppReset(context.Context, *Identity) (*AppStatusRes, error)
	AppStop(context.Context, *Identity) (*AppStatusRes, error)
	AppStart(context.Context, *Identity) (*AppStatusRes, error)
	// TTY disable for now
	AppShell(context.Context, *ShellReq) (*Chunk, error)
	AppAttachVolume(context.Context, *VolumeMount) (*AppStatusRes, error)
	AppDetachVolume(context.Context, *AttachIdentity) (*AppStatusRes, error)
	AppAttachDomain(context.Context, *SrvDomainAttachReq) (*AppStatusRes, error)
	AppDetachDomain(context.Context, *SrvDomainAttachReq) (*AppStatusRes, error)
	AppSrvBind(context.Context, *AppSrvBindReq) (*AppStatusRes, error)
	AppSrvUnBind(context.Context, *AppSrvBindReq) (*AppStatusRes, error)
	AppFTPPortforward(context.Context, *Identity) (*PortforwardRes, error)
	mustEmbedUnimplementedYBServer()
}

// UnimplementedYBServer must be embedded to have forward compatible implementations.
type UnimplementedYBServer struct {
}

func (UnimplementedYBServer) Login(context.Context, *LoginReq) (*AuthenticationRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedYBServer) Logout(context.Context, *Empty) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedYBServer) AccountInfo(context.Context, *Empty) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInfo not implemented")
}
func (UnimplementedYBServer) AccountUpdate(context.Context, *Account) (*Account, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountUpdate not implemented")
}
func (UnimplementedYBServer) MonitoringQuota(context.Context, *Empty) (*ResourcesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonitoringQuota not implemented")
}
func (UnimplementedYBServer) MonitoringResource(context.Context, *Identity) (*ResourcesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonitoringResource not implemented")
}
func (UnimplementedYBServer) MonitoringTraffic(context.Context, *Identity) (*TrafficRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonitoringTraffic not implemented")
}
func (UnimplementedYBServer) MonitoringLatency(context.Context, *Identity) (*LatencyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MonitoringLatency not implemented")
}
func (UnimplementedYBServer) ActivityList(context.Context, *ActivityReq) (*ActivityListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivityList not implemented")
}
func (UnimplementedYBServer) DomainList(context.Context, *AppListReq) (*DomainListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainList not implemented")
}
func (UnimplementedYBServer) DomainInfo(context.Context, *Identity) (*DomainStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainInfo not implemented")
}
func (UnimplementedYBServer) DomainToggleTLS(context.Context, *Identity) (*DomainStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainToggleTLS not implemented")
}
func (UnimplementedYBServer) DomainCreate(context.Context, *DomainCreateReq) (*DomainStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainCreate not implemented")
}
func (UnimplementedYBServer) DomainDelete(context.Context, *Identity) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainDelete not implemented")
}
func (UnimplementedYBServer) VolumeSpecList(context.Context, *ListReq) (*VolumeSpecListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeSpecList not implemented")
}
func (UnimplementedYBServer) VolumeList(context.Context, *AppListReq) (*VolumeListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeList not implemented")
}
func (UnimplementedYBServer) VolumeInfo(context.Context, *Identity) (*VolumeStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeInfo not implemented")
}
func (UnimplementedYBServer) VolumeCreate(context.Context, *VolumeCreateReq) (*VolumeStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeCreate not implemented")
}
func (UnimplementedYBServer) VolumeDelete(context.Context, *Identity) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeDelete not implemented")
}
func (UnimplementedYBServer) VolumeFTPPortforward(context.Context, *Identity) (*PortforwardRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeFTPPortforward not implemented")
}
func (UnimplementedYBServer) ImgList(context.Context, *AppListReq) (*ImgListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgList not implemented")
}
func (UnimplementedYBServer) ImgInfo(context.Context, *Identity) (*ImgStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgInfo not implemented")
}
func (UnimplementedYBServer) ImgDelete(context.Context, *ImgBuildReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgDelete not implemented")
}
func (UnimplementedYBServer) ImgBuild(context.Context, *ImgBuildReq) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgBuild not implemented")
}
func (UnimplementedYBServer) ImgBuildLog(*Identity, YB_ImgBuildLogServer) error {
	return status.Errorf(codes.Unimplemented, "method ImgBuildLog not implemented")
}
func (UnimplementedYBServer) ImgBuildLogTail(context.Context, *TailRequest) (*Chunk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImgBuildLogTail not implemented")
}
func (UnimplementedYBServer) PrdList(context.Context, *ListReq) (*PrdListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrdList not implemented")
}
func (UnimplementedYBServer) PrdInfo(context.Context, *Identity) (*ProductRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrdInfo not implemented")
}
func (UnimplementedYBServer) SrvList(context.Context, *AppListReq) (*SrvListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvList not implemented")
}
func (UnimplementedYBServer) SrvInfo(context.Context, *Identity) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvInfo not implemented")
}
func (UnimplementedYBServer) SrvCreate(context.Context, *SrvCreateReq) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvCreate not implemented")
}
func (UnimplementedYBServer) SrvDestroy(context.Context, *Identity) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvDestroy not implemented")
}
func (UnimplementedYBServer) SrvStart(context.Context, *Identity) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvStart not implemented")
}
func (UnimplementedYBServer) SrvStop(context.Context, *Identity) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvStop not implemented")
}
func (UnimplementedYBServer) SrvAttachDomain(context.Context, *SrvDomainAttachReq) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvAttachDomain not implemented")
}
func (UnimplementedYBServer) SrvDetachDomain(context.Context, *SrvDomainAttachReq) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvDetachDomain not implemented")
}
func (UnimplementedYBServer) SrvOperator(context.Context, *PunchedCard) (*OperatorRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvOperator not implemented")
}
func (UnimplementedYBServer) SrvPortforward(context.Context, *Identity) (*PortforwardRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvPortforward not implemented")
}
func (UnimplementedYBServer) SrvConfigSet(context.Context, *SrvConfigSetReq) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvConfigSet not implemented")
}
func (UnimplementedYBServer) SrvConfigUnset(context.Context, *UnsetReq) (*SrvStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SrvConfigUnset not implemented")
}
func (UnimplementedYBServer) AppList(context.Context, *ListReq) (*SrvListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppList not implemented")
}
func (UnimplementedYBServer) AppInfo(context.Context, *Identity) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfo not implemented")
}
func (UnimplementedYBServer) AppCreate(context.Context, *AppCreateReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppCreate not implemented")
}
func (UnimplementedYBServer) AppDestroy(context.Context, *Identity) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppDestroy not implemented")
}
func (UnimplementedYBServer) AppChangePlan(context.Context, *ChangePlanReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppChangePlan not implemented")
}
func (UnimplementedYBServer) AppLog(*Identity, YB_AppLogServer) error {
	return status.Errorf(codes.Unimplemented, "method AppLog not implemented")
}
func (UnimplementedYBServer) AppLogTail(context.Context, *TailRequest) (*Chunk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppLogTail not implemented")
}
func (UnimplementedYBServer) AppConfigSet(context.Context, *SrvConfigSetReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppConfigSet not implemented")
}
func (UnimplementedYBServer) AppConfigUnset(context.Context, *UnsetReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppConfigUnset not implemented")
}
func (UnimplementedYBServer) AppAddEnvironmentVariable(context.Context, *AppAddEnvironmentVariableReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppAddEnvironmentVariable not implemented")
}
func (UnimplementedYBServer) AppRemoveEnvironmentVariable(context.Context, *UnsetReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppRemoveEnvironmentVariable not implemented")
}
func (UnimplementedYBServer) AppReset(context.Context, *Identity) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppReset not implemented")
}
func (UnimplementedYBServer) AppStop(context.Context, *Identity) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppStop not implemented")
}
func (UnimplementedYBServer) AppStart(context.Context, *Identity) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppStart not implemented")
}
func (UnimplementedYBServer) AppShell(context.Context, *ShellReq) (*Chunk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppShell not implemented")
}
func (UnimplementedYBServer) AppAttachVolume(context.Context, *VolumeMount) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppAttachVolume not implemented")
}
func (UnimplementedYBServer) AppDetachVolume(context.Context, *AttachIdentity) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppDetachVolume not implemented")
}
func (UnimplementedYBServer) AppAttachDomain(context.Context, *SrvDomainAttachReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppAttachDomain not implemented")
}
func (UnimplementedYBServer) AppDetachDomain(context.Context, *SrvDomainAttachReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppDetachDomain not implemented")
}
func (UnimplementedYBServer) AppSrvBind(context.Context, *AppSrvBindReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppSrvBind not implemented")
}
func (UnimplementedYBServer) AppSrvUnBind(context.Context, *AppSrvBindReq) (*AppStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppSrvUnBind not implemented")
}
func (UnimplementedYBServer) AppFTPPortforward(context.Context, *Identity) (*PortforwardRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppFTPPortforward not implemented")
}
func (UnimplementedYBServer) mustEmbedUnimplementedYBServer() {}

// UnsafeYBServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to YBServer will
// result in compilation errors.
type UnsafeYBServer interface {
	mustEmbedUnimplementedYBServer()
}

func RegisterYBServer(s grpc.ServiceRegistrar, srv YBServer) {
	s.RegisterService(&YB_ServiceDesc, srv)
}

func _YB_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).Logout(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AccountInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AccountInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AccountUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AccountUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AccountUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AccountUpdate(ctx, req.(*Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_MonitoringQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).MonitoringQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_MonitoringQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).MonitoringQuota(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_MonitoringResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).MonitoringResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_MonitoringResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).MonitoringResource(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_MonitoringTraffic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).MonitoringTraffic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_MonitoringTraffic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).MonitoringTraffic(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_MonitoringLatency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).MonitoringLatency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_MonitoringLatency_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).MonitoringLatency(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ActivityList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ActivityList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ActivityList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ActivityList(ctx, req.(*ActivityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_DomainList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).DomainList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_DomainList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).DomainList(ctx, req.(*AppListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_DomainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).DomainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_DomainInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).DomainInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_DomainToggleTLS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).DomainToggleTLS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_DomainToggleTLS_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).DomainToggleTLS(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_DomainCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DomainCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).DomainCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_DomainCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).DomainCreate(ctx, req.(*DomainCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_DomainDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).DomainDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_DomainDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).DomainDelete(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeSpecList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeSpecList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeSpecList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeSpecList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeList(ctx, req.(*AppListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeCreate(ctx, req.(*VolumeCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeDelete(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_VolumeFTPPortforward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).VolumeFTPPortforward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_VolumeFTPPortforward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).VolumeFTPPortforward(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ImgList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ImgList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ImgList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ImgList(ctx, req.(*AppListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ImgInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ImgInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ImgInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ImgInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ImgDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImgBuildReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ImgDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ImgDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ImgDelete(ctx, req.(*ImgBuildReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ImgBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImgBuildReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ImgBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ImgBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ImgBuild(ctx, req.(*ImgBuildReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_ImgBuildLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Identity)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YBServer).ImgBuildLog(m, &yBImgBuildLogServer{stream})
}

type YB_ImgBuildLogServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type yBImgBuildLogServer struct {
	grpc.ServerStream
}

func (x *yBImgBuildLogServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _YB_ImgBuildLogTail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).ImgBuildLogTail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_ImgBuildLogTail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).ImgBuildLogTail(ctx, req.(*TailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_PrdList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).PrdList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_PrdList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).PrdList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_PrdInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).PrdInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_PrdInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).PrdInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvList(ctx, req.(*AppListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvCreate(ctx, req.(*SrvCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvDestroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvDestroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvDestroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvDestroy(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvStart(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvStop(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvAttachDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvDomainAttachReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvAttachDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvAttachDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvAttachDomain(ctx, req.(*SrvDomainAttachReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvDetachDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvDomainAttachReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvDetachDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvDetachDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvDetachDomain(ctx, req.(*SrvDomainAttachReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PunchedCard)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvOperator(ctx, req.(*PunchedCard))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvPortforward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvPortforward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvPortforward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvPortforward(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvConfigSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvConfigSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvConfigSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvConfigSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvConfigSet(ctx, req.(*SrvConfigSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_SrvConfigUnset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).SrvConfigUnset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_SrvConfigUnset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).SrvConfigUnset(ctx, req.(*UnsetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppList(ctx, req.(*ListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppInfo(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppCreate(ctx, req.(*AppCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppDestroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppDestroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppDestroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppDestroy(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppChangePlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePlanReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppChangePlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppChangePlan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppChangePlan(ctx, req.(*ChangePlanReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Identity)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(YBServer).AppLog(m, &yBAppLogServer{stream})
}

type YB_AppLogServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type yBAppLogServer struct {
	grpc.ServerStream
}

func (x *yBAppLogServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

func _YB_AppLogTail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppLogTail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppLogTail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppLogTail(ctx, req.(*TailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppConfigSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvConfigSetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppConfigSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppConfigSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppConfigSet(ctx, req.(*SrvConfigSetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppConfigUnset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppConfigUnset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppConfigUnset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppConfigUnset(ctx, req.(*UnsetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppAddEnvironmentVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppAddEnvironmentVariableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppAddEnvironmentVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppAddEnvironmentVariable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppAddEnvironmentVariable(ctx, req.(*AppAddEnvironmentVariableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppRemoveEnvironmentVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppRemoveEnvironmentVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppRemoveEnvironmentVariable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppRemoveEnvironmentVariable(ctx, req.(*UnsetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppReset(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppStop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppStop(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppStart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppStart(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppShell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShellReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppShell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppShell_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppShell(ctx, req.(*ShellReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppAttachVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeMount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppAttachVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppAttachVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppAttachVolume(ctx, req.(*VolumeMount))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppDetachVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachIdentity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppDetachVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppDetachVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppDetachVolume(ctx, req.(*AttachIdentity))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppAttachDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvDomainAttachReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppAttachDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppAttachDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppAttachDomain(ctx, req.(*SrvDomainAttachReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppDetachDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrvDomainAttachReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppDetachDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppDetachDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppDetachDomain(ctx, req.(*SrvDomainAttachReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppSrvBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppSrvBindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppSrvBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppSrvBind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppSrvBind(ctx, req.(*AppSrvBindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppSrvUnBind_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppSrvBindReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppSrvUnBind(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppSrvUnBind_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppSrvUnBind(ctx, req.(*AppSrvBindReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _YB_AppFTPPortforward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Identity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(YBServer).AppFTPPortforward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: YB_AppFTPPortforward_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(YBServer).AppFTPPortforward(ctx, req.(*Identity))
	}
	return interceptor(ctx, in, info, handler)
}

// YB_ServiceDesc is the grpc.ServiceDesc for YB service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var YB_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yb.YB",
	HandlerType: (*YBServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _YB_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _YB_Logout_Handler,
		},
		{
			MethodName: "AccountInfo",
			Handler:    _YB_AccountInfo_Handler,
		},
		{
			MethodName: "AccountUpdate",
			Handler:    _YB_AccountUpdate_Handler,
		},
		{
			MethodName: "MonitoringQuota",
			Handler:    _YB_MonitoringQuota_Handler,
		},
		{
			MethodName: "MonitoringResource",
			Handler:    _YB_MonitoringResource_Handler,
		},
		{
			MethodName: "MonitoringTraffic",
			Handler:    _YB_MonitoringTraffic_Handler,
		},
		{
			MethodName: "MonitoringLatency",
			Handler:    _YB_MonitoringLatency_Handler,
		},
		{
			MethodName: "ActivityList",
			Handler:    _YB_ActivityList_Handler,
		},
		{
			MethodName: "DomainList",
			Handler:    _YB_DomainList_Handler,
		},
		{
			MethodName: "DomainInfo",
			Handler:    _YB_DomainInfo_Handler,
		},
		{
			MethodName: "DomainToggleTLS",
			Handler:    _YB_DomainToggleTLS_Handler,
		},
		{
			MethodName: "DomainCreate",
			Handler:    _YB_DomainCreate_Handler,
		},
		{
			MethodName: "DomainDelete",
			Handler:    _YB_DomainDelete_Handler,
		},
		{
			MethodName: "VolumeSpecList",
			Handler:    _YB_VolumeSpecList_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _YB_VolumeList_Handler,
		},
		{
			MethodName: "VolumeInfo",
			Handler:    _YB_VolumeInfo_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _YB_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _YB_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeFTPPortforward",
			Handler:    _YB_VolumeFTPPortforward_Handler,
		},
		{
			MethodName: "ImgList",
			Handler:    _YB_ImgList_Handler,
		},
		{
			MethodName: "ImgInfo",
			Handler:    _YB_ImgInfo_Handler,
		},
		{
			MethodName: "ImgDelete",
			Handler:    _YB_ImgDelete_Handler,
		},
		{
			MethodName: "ImgBuild",
			Handler:    _YB_ImgBuild_Handler,
		},
		{
			MethodName: "ImgBuildLogTail",
			Handler:    _YB_ImgBuildLogTail_Handler,
		},
		{
			MethodName: "PrdList",
			Handler:    _YB_PrdList_Handler,
		},
		{
			MethodName: "PrdInfo",
			Handler:    _YB_PrdInfo_Handler,
		},
		{
			MethodName: "SrvList",
			Handler:    _YB_SrvList_Handler,
		},
		{
			MethodName: "SrvInfo",
			Handler:    _YB_SrvInfo_Handler,
		},
		{
			MethodName: "SrvCreate",
			Handler:    _YB_SrvCreate_Handler,
		},
		{
			MethodName: "SrvDestroy",
			Handler:    _YB_SrvDestroy_Handler,
		},
		{
			MethodName: "SrvStart",
			Handler:    _YB_SrvStart_Handler,
		},
		{
			MethodName: "SrvStop",
			Handler:    _YB_SrvStop_Handler,
		},
		{
			MethodName: "SrvAttachDomain",
			Handler:    _YB_SrvAttachDomain_Handler,
		},
		{
			MethodName: "SrvDetachDomain",
			Handler:    _YB_SrvDetachDomain_Handler,
		},
		{
			MethodName: "SrvOperator",
			Handler:    _YB_SrvOperator_Handler,
		},
		{
			MethodName: "SrvPortforward",
			Handler:    _YB_SrvPortforward_Handler,
		},
		{
			MethodName: "SrvConfigSet",
			Handler:    _YB_SrvConfigSet_Handler,
		},
		{
			MethodName: "SrvConfigUnset",
			Handler:    _YB_SrvConfigUnset_Handler,
		},
		{
			MethodName: "AppList",
			Handler:    _YB_AppList_Handler,
		},
		{
			MethodName: "AppInfo",
			Handler:    _YB_AppInfo_Handler,
		},
		{
			MethodName: "AppCreate",
			Handler:    _YB_AppCreate_Handler,
		},
		{
			MethodName: "AppDestroy",
			Handler:    _YB_AppDestroy_Handler,
		},
		{
			MethodName: "AppChangePlan",
			Handler:    _YB_AppChangePlan_Handler,
		},
		{
			MethodName: "AppLogTail",
			Handler:    _YB_AppLogTail_Handler,
		},
		{
			MethodName: "AppConfigSet",
			Handler:    _YB_AppConfigSet_Handler,
		},
		{
			MethodName: "AppConfigUnset",
			Handler:    _YB_AppConfigUnset_Handler,
		},
		{
			MethodName: "AppAddEnvironmentVariable",
			Handler:    _YB_AppAddEnvironmentVariable_Handler,
		},
		{
			MethodName: "AppRemoveEnvironmentVariable",
			Handler:    _YB_AppRemoveEnvironmentVariable_Handler,
		},
		{
			MethodName: "AppReset",
			Handler:    _YB_AppReset_Handler,
		},
		{
			MethodName: "AppStop",
			Handler:    _YB_AppStop_Handler,
		},
		{
			MethodName: "AppStart",
			Handler:    _YB_AppStart_Handler,
		},
		{
			MethodName: "AppShell",
			Handler:    _YB_AppShell_Handler,
		},
		{
			MethodName: "AppAttachVolume",
			Handler:    _YB_AppAttachVolume_Handler,
		},
		{
			MethodName: "AppDetachVolume",
			Handler:    _YB_AppDetachVolume_Handler,
		},
		{
			MethodName: "AppAttachDomain",
			Handler:    _YB_AppAttachDomain_Handler,
		},
		{
			MethodName: "AppDetachDomain",
			Handler:    _YB_AppDetachDomain_Handler,
		},
		{
			MethodName: "AppSrvBind",
			Handler:    _YB_AppSrvBind_Handler,
		},
		{
			MethodName: "AppSrvUnBind",
			Handler:    _YB_AppSrvUnBind_Handler,
		},
		{
			MethodName: "AppFTPPortforward",
			Handler:    _YB_AppFTPPortforward_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ImgBuildLog",
			Handler:       _YB_ImgBuildLog_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AppLog",
			Handler:       _YB_AppLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "YB.proto",
}
